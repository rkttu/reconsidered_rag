# 다시 생각하는 RAG (Reconsidered RAG)

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Python](https://img.shields.io/badge/Python-3.11%2B-blue.svg)](https://www.python.org/)
[![MCP](https://img.shields.io/badge/MCP-Compatible-green.svg)](https://modelcontextprotocol.io/)
[![GitHub Sponsors](https://img.shields.io/github/sponsors/rkttu)](https://github.com/sponsors/rkttu)

**[English](README.md)** | 한국어

[![데모 보기](https://img.youtube.com/vi/Uj6Vz5CZ4c4/maxresdefault.jpg)](https://youtu.be/Uj6Vz5CZ4c4)

Reconsidered RAG(다시 생각하는 RAG)는  
책임, 데이터 주권, 그리고 실패 경계가 중요한 환경에서  
검색 증강 생성(Retrieval-Augmented Generation, RAG)을  
**어디까지, 언제, 어떤 방식으로 사용해야 하는지 다시 묻는 레퍼런스 프로젝트**입니다.

이 프로젝트의 이전 이름은 **AIPACK**이었습니다.

---

## 이 프로젝트가 존재하는 이유

Reconsidered RAG는 다음과 같은 질문에서 출발했습니다.

> “왜 대부분의 RAG 논의는  
> 시작부터 GPU와 고비용 클라우드 서비스를 전제로 할까?”

많은 RAG 구현은 다음을 당연한 출발점으로 삼습니다.

- 임베딩은 즉시 생성되어야 한다
- 벡터는 최대한 많이 쌓아야 한다
- 관리형 하이브리드 검색이 기본이다
- 비용은 나중에 최적화하면 된다

그러나 개인 프로젝트나 장기 유지가 필요한 시스템,
혹은 규제·책임이 수반되는 환경에서는  
이러한 전제가 처음부터 성립하지 않는 경우가 많습니다.

Reconsidered RAG는  
**“그 방향으로 갈 수 없었던 상황”에서 시작된 판단 기록**입니다.

---

## 이 프로젝트가 집중하는 것

이 프로젝트는 다음에 집중합니다.

- 검색 대상이 되기 *이전*에 텍스트를 어떻게 다뤄야 하는지
- 어떤 시점에서 의미를 고정(embedding)해야 하는지, 혹은 하지 말아야 하는지
- 시스템이 언제 답변을 *거부*해야 하는지
- 최종적인 책임이 모델이나 서비스가 아닌 **사람에게 어떻게 남는지**

이 저장소의 코드는 이러한 고민을 구체화하기 위한  
**레퍼런스 구현**이며, 그대로 복사해 쓰기 위한 청사진이 아닙니다.

---

## 이 프로젝트가 다루지 않는 것

Reconsidered RAG는 의도적으로 다음과 같이 **포지셔닝되지 않습니다**.

- **제품이나 서비스가 아닙니다**  
  SaaS, 플랫폼, 또는 범용 배포 솔루션이 아닙니다.
  즉시 사용할 수 있는 프로덕션 시스템을 제공하지 않습니다.

- **프레임워크나 툴킷이 아닙니다**  
  RAG의 “정답 구현”을 제시하지 않습니다.
  대신 RAG가 *어디서 실패하는지*를 문서화합니다.

- **성능 벤치마크가 아닙니다**  
  정확도, 속도, 모델 성능 비교는 핵심 관심사가 아닙니다.
  책임과 통제가 불명확하다면 더 나은 성능은 의미가 없습니다.

- **비용 절감을 약속하는 프로젝트가 아닙니다**  
  GPU를 쓰지 않는 것은 목표가 아니라 결과입니다.
  이 단계가 추론이 아니라 판단과 편집의 영역이기 때문입니다.

- **안전을 보장하지 않습니다**  
  AI 시스템을 완전히 안전하게 만들 수 있다고 주장하지 않습니다.
  위험을 드러내고, 논의 가능하게 만들기 위해 존재합니다.

---

## 설계 원칙

Reconsidered RAG는 다음 원칙에 따라 설계되었습니다.

- **암묵적 단계보다 명시적 편집점**  
  RAG 파이프라인은 하나의 자동 흐름이 아니라,
  사람이 개입할 수 있는 편집 지점들의 연쇄로 구성되어야 합니다.

- **의미 고정은 가능한 한 늦게**  
  임베딩은 의미를 고정하는 행위입니다.
  고정 전에 판단과 검증의 여지를 남깁니다.

- **거부는 실패가 아닙니다**  
  모든 질문에 답하는 것이 목표가 아닙니다.
  답하지 않는 것이 더 책임 있는 선택일 수 있습니다.

- **제약은 숨기지 않습니다**  
  한계, 트레이드오프, 비목표를 명시적으로 드러냅니다.

- **성공보다 실패를 먼저 봅니다**  
  특히 모호하거나 적대적인 조건에서
  시스템이 어떻게 무너지는지를 우선적으로 다룹니다.

---

## 우리가 명시적으로 다루는 실패 모드

이 프로젝트는 다음과 같은 실패를 전제로 합니다.

- 검색 범위가 조용히 확장되는 문제
- 의도치 않은 문서가 검색 대상에 포함되는 문제
- 약한 근거 위에서 과신하는 답변
- 거부 경로가 없는 설계
- 문제가 발생했을 때 책임 주체가 사라지는 구조

이것들은 예외가 아니라,
경계를 명시하지 않을 때 *반드시* 발생하는 결과입니다.

---

## 레퍼런스 구현의 핵심 특징

이 저장소의 구현은 다음과 같은 선택을 의도적으로 합니다.

- RAG 파이프라인을 **프로젝션/위빙 단계와 검색 단계로 분리**
- 프로젝션 단계에서는 텍스트를 자르고 맥락을 정리하지만,
  **임베딩 벡터는 생성하거나 저장하지 않음**
- 중간 결과를 parquet 파일로 저장하여
  사람이 검토 가능한 상태로 유지
- 이 전 과정은 **GPU 없이 CPU만으로 수행 가능**

이는 저사양을 목표로 한 설계가 아니라,  
**의미를 언제 고정할 것인지에 대한 결정을 뒤로 미루기 위한 설계**입니다.

---

## 구현 세부사항

구체적인 기술 구현은 별도의 문서로 분리되어 있습니다.

- 아키텍처 및 데이터 흐름
- 설치 및 실행 방법
- 모듈 구성
- 설정 옵션
- Docker 환경
- IDE 연동

자세한 내용은 **[IMPLEMENTATION.md](IMPLEMENTATION.md)** 를 참고하세요.

---

## 대상 독자

Reconsidered RAG는 다음과 같은 독자를 상정합니다.

- GPU와 고비용 클라우드 서비스를 전제로 할 수 없는 환경
- 데이터와 책임에 민감한 조직
- RAG를 “한 번 만들고 끝낼 수 없는” 상황에 있는 사람들

빠른 PoC나 성능 경쟁을 원하는 팀에는 적합하지 않습니다.

---

## 마지막으로

Reconsidered RAG는  
배포를 가속하기 위해 존재하지 않습니다.

이 저장소가  
“문서 하나만 더 넣어도 되지 않을까?”라는 순간에  
당신을 한 번 멈추게 만든다면,  
이미 역할을 다한 것입니다.
